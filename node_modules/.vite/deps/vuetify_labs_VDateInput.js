import {
  VConfirmEdit,
  VDatePicker,
  VMenu,
  VTextField,
  makeFocusProps,
  makeVConfirmEditProps,
  makeVDatePickerProps,
  makeVTextFieldProps
} from "./chunk-PI2F42R5.js";
import {
  createDateRange,
  useDate
} from "./chunk-33Z5QT5I.js";
import {
  forwardRefs
} from "./chunk-NV2OU4GG.js";
import {
  makeDisplayProps,
  useDisplay,
  useLocale
} from "./chunk-YTTYO2PH.js";
import "./chunk-4QDJ3KUZ.js";
import {
  consoleWarn,
  genericComponent,
  omit,
  propsFactory,
  useProxiedModel,
  useRender,
  wrapInArray
} from "./chunk-QDLGESDK.js";
import {
  Fragment,
  computed,
  createBaseVNode,
  createVNode,
  mergeProps,
  ref,
  shallowRef,
  toRef,
  watch
} from "./chunk-H3YH6CFY.js";

// node_modules/.pnpm/vuetify@3.9.2_typescript@5.8.3_vue@3.5.17_typescript@5.8.3_/node_modules/vuetify/lib/composables/dateFormat.js
var DateFormatSpec = class _DateFormatSpec {
  constructor(order, separator) {
    this.order = order;
    this.separator = separator;
  }
  get format() {
    return this.order.split("").map((sign) => `${sign}${sign}`).join(this.separator).replace("yy", "yyyy");
  }
  static canBeParsed(v) {
    if (typeof v !== "string")
      return false;
    const lowercase = v.toLowerCase();
    return ["y", "m", "d"].every((sign) => lowercase.includes(sign)) && ["/", "-", "."].some((sign) => v.includes(sign));
  }
  static parse(v) {
    if (!_DateFormatSpec.canBeParsed(v)) {
      throw new Error(`[${v}] cannot be parsed into date format specification`);
    }
    const order = v.toLowerCase().split("").filter((c, i, all) => "dmy".includes(c) && all.indexOf(c) === i).join("");
    const separator = ["/", "-", "."].find((sign) => v.includes(sign));
    return new _DateFormatSpec(order, separator);
  }
};
var makeDateFormatProps = propsFactory({
  inputFormat: {
    type: String,
    validator: (v) => !v || DateFormatSpec.canBeParsed(v)
  }
}, "date-format");
function useDateFormat(props, locale) {
  const adapter = useDate();
  function inferFromLocale() {
    const localeForDateFormat = locale.value ?? "en-US";
    const formatFromLocale = Intl.DateTimeFormat(localeForDateFormat, {
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    }).format(adapter.toJsDate(adapter.parseISO("1999-12-07"))).replace(/(07)|(٠٧)|(٢٩)|(۱۶)|(০৭)/, "dd").replace(/(12)|(١٢)|(٠٨)|(۰۹)|(১২)/, "mm").replace(/(1999)|(2542)|(١٩٩٩)|(١٤٢٠)|(۱۳۷۸)|(১৯৯৯)/, "yyyy").replace(/[^ymd\-/.]/g, "").replace(/\.$/, "");
    if (!DateFormatSpec.canBeParsed(formatFromLocale)) {
      consoleWarn(`Date format inferred from locale [${localeForDateFormat}] is invalid: [${formatFromLocale}]`);
      return "mm/dd/yyyy";
    }
    return formatFromLocale;
  }
  const currentFormat = toRef(() => {
    return DateFormatSpec.canBeParsed(props.inputFormat) ? DateFormatSpec.parse(props.inputFormat) : DateFormatSpec.parse(inferFromLocale());
  });
  function parseDate(dateString) {
    function parseDateParts(text) {
      const parts = text.trim().split(currentFormat.value.separator);
      return {
        y: Number(parts[currentFormat.value.order.indexOf("y")]),
        m: Number(parts[currentFormat.value.order.indexOf("m")]),
        d: Number(parts[currentFormat.value.order.indexOf("d")])
      };
    }
    function validateDateParts(dateParts2) {
      const {
        y: year2,
        m: month2,
        d: day2
      } = dateParts2;
      if (!year2 || !month2 || !day2)
        return null;
      if (month2 < 1 || month2 > 12)
        return null;
      if (day2 < 1 || day2 > 31)
        return null;
      return {
        year: autoFixYear(year2),
        month: month2,
        day: day2
      };
    }
    function autoFixYear(year2) {
      const currentYear = adapter.getYear(adapter.date());
      if (year2 > 100 || currentYear % 100 >= 50) {
        return year2;
      }
      const currentCentury = ~~(currentYear / 100) * 100;
      return year2 < 50 ? currentCentury + year2 : currentCentury - 100 + year2;
    }
    const dateParts = parseDateParts(dateString);
    const validatedParts = validateDateParts(dateParts);
    if (!validatedParts)
      return null;
    const {
      year,
      month,
      day
    } = validatedParts;
    const pad = (v) => String(v).padStart(2, "0");
    return adapter.parseISO(`${year}-${pad(month)}-${pad(day)}`);
  }
  function isValid(text) {
    return !!parseDate(text);
  }
  function formatDate(value) {
    const parts = adapter.toISO(value).split("T")[0].split("-");
    return currentFormat.value.order.split("").map((sign) => parts["ymd".indexOf(sign)]).join(currentFormat.value.separator);
  }
  return {
    isValid,
    parseDate,
    formatDate,
    parserFormat: toRef(() => currentFormat.value.format)
  };
}

// node_modules/.pnpm/vuetify@3.9.2_typescript@5.8.3_vue@3.5.17_typescript@5.8.3_/node_modules/vuetify/lib/labs/VDateInput/VDateInput.js
var makeVDateInputProps = propsFactory({
  displayFormat: {
    type: [Function, String],
    default: void 0
  },
  location: {
    type: String,
    default: "bottom start"
  },
  menu: Boolean,
  updateOn: {
    type: Array,
    default: () => ["blur", "enter"]
  },
  ...makeDateFormatProps(),
  ...makeDisplayProps({
    mobile: null
  }),
  ...makeFocusProps(),
  ...makeVConfirmEditProps({
    hideActions: true
  }),
  ...makeVTextFieldProps({
    prependIcon: "$calendar"
  }),
  ...omit(makeVDatePickerProps({
    hideHeader: true,
    showAdjacentMonths: true
  }), ["active", "location", "rounded"])
}, "VDateInput");
var VDateInput = genericComponent()({
  name: "VDateInput",
  props: makeVDateInputProps(),
  emits: {
    save: (value) => true,
    cancel: () => true,
    "update:focused": (val) => true,
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const {
      t,
      current: currentLocale
    } = useLocale();
    const adapter = useDate();
    const {
      isValid,
      parseDate,
      formatDate,
      parserFormat
    } = useDateFormat(props, currentLocale);
    const {
      mobile
    } = useDisplay(props);
    const emptyModelValue = () => props.multiple ? [] : null;
    const model = useProxiedModel(props, "modelValue", emptyModelValue(), (val) => Array.isArray(val) ? val.map((item) => adapter.toJsDate(item)) : val ? adapter.toJsDate(val) : val, (val) => Array.isArray(val) ? val.map((item) => adapter.date(item)) : val ? adapter.date(val) : val);
    const menu = useProxiedModel(props, "menu");
    const isEditingInput = shallowRef(false);
    const isFocused = shallowRef(props.focused);
    const vTextFieldRef = ref();
    const disabledActions = ref(["save"]);
    function format(date) {
      if (typeof props.displayFormat === "function") {
        return props.displayFormat(date);
      }
      if (props.displayFormat) {
        return adapter.format(date, props.displayFormat ?? "keyboardDate");
      }
      return formatDate(date);
    }
    const display = computed(() => {
      const value = wrapInArray(model.value);
      if (!value.length)
        return null;
      if (props.multiple === true) {
        return t("$vuetify.datePicker.itemsSelected", value.length);
      }
      if (props.multiple === "range") {
        const start = value[0];
        const end = value[value.length - 1];
        if (!adapter.isValid(start) || !adapter.isValid(end))
          return "";
        return `${format(adapter.date(start))} - ${format(adapter.date(end))}`;
      }
      return adapter.isValid(model.value) ? format(adapter.date(model.value)) : "";
    });
    const inputmode = computed(() => {
      if (!mobile.value)
        return void 0;
      if (isEditingInput.value)
        return "text";
      return "none";
    });
    const isInteractive = computed(() => !props.disabled && !props.readonly);
    const isReadonly = computed(() => {
      if (!props.updateOn.length)
        return true;
      return !(mobile.value && isEditingInput.value) && props.readonly;
    });
    watch(menu, (val) => {
      if (val)
        return;
      isEditingInput.value = false;
      disabledActions.value = ["save"];
    });
    function onKeydown(e) {
      if (e.key !== "Enter")
        return;
      if (!menu.value || !isFocused.value) {
        menu.value = true;
      }
      if (props.updateOn.includes("enter")) {
        onUserInput(e.target);
      }
    }
    function onClick(e) {
      e.preventDefault();
      e.stopPropagation();
      if (menu.value && mobile.value) {
        isEditingInput.value = true;
      } else {
        menu.value = true;
      }
    }
    function onCancel() {
      emit("cancel");
      menu.value = false;
      isEditingInput.value = false;
    }
    function onSave(value) {
      emit("save", value);
      menu.value = false;
    }
    function onUpdateDisplayModel(value) {
      if (value != null)
        return;
      model.value = emptyModelValue();
    }
    function onBlur(e) {
      if (props.updateOn.includes("blur")) {
        onUserInput(e.target);
      }
      if (mobile.value && isEditingInput.value && !isFocused.value) {
        menu.value = false;
        isEditingInput.value = false;
      }
    }
    function onUserInput(_ref2) {
      let {
        value
      } = _ref2;
      if (!value.trim()) {
        model.value = emptyModelValue();
      } else if (!props.multiple) {
        if (isValid(value)) {
          model.value = parseDate(value);
        }
      } else {
        const parts = value.trim().split(/\D+-\D+|[^\d\-/.]+/);
        if (parts.every(isValid)) {
          if (props.multiple === "range") {
            const [start, stop] = parts.map(parseDate).toSorted((a, b) => adapter.isAfter(a, b) ? 1 : -1);
            model.value = createDateRange(adapter, start, stop);
          } else {
            model.value = parts.map(parseDate);
          }
        }
      }
    }
    useRender(() => {
      const confirmEditProps = VConfirmEdit.filterProps(props);
      const datePickerProps = VDatePicker.filterProps(omit(props, ["active", "location", "rounded"]));
      const textFieldProps = VTextField.filterProps(omit(props, ["placeholder"]));
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "class": props.class,
        "style": props.style,
        "modelValue": display.value,
        "inputmode": inputmode.value,
        "placeholder": props.placeholder ?? parserFormat.value,
        "readonly": isReadonly.value,
        "onKeydown": isInteractive.value ? onKeydown : void 0,
        "focused": menu.value || isFocused.value,
        "onBlur": onBlur,
        "validationValue": model.value,
        "onClick:control": isInteractive.value ? onClick : void 0,
        "onClick:prepend": isInteractive.value ? onClick : void 0,
        "onUpdate:modelValue": onUpdateDisplayModel,
        "onUpdate:focused": (event) => isFocused.value = event
      }), {
        ...slots,
        default: () => {
          var _a;
          return createBaseVNode(Fragment, null, [createVNode(VMenu, {
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "minWidth": "0",
            "eager": isFocused.value,
            "location": props.location,
            "closeOnContentClick": false,
            "openOnClick": false
          }, {
            default: () => [createVNode(VConfirmEdit, mergeProps(confirmEditProps, {
              "modelValue": model.value,
              "onUpdate:modelValue": ($event) => model.value = $event,
              "disabled": disabledActions.value,
              "onSave": onSave,
              "onCancel": onCancel
            }), {
              default: (_ref3) => {
                let {
                  actions,
                  model: proxyModel,
                  save,
                  cancel,
                  isPristine
                } = _ref3;
                function onUpdateModel(value) {
                  if (!props.hideActions) {
                    proxyModel.value = value;
                  } else {
                    model.value = value;
                    if (!props.multiple) {
                      menu.value = false;
                    }
                  }
                  emit("save", value);
                  disabledActions.value = [];
                }
                return createVNode(VDatePicker, mergeProps(datePickerProps, {
                  "modelValue": props.hideActions ? model.value : proxyModel.value,
                  "onUpdate:modelValue": (value) => onUpdateModel(value),
                  "onMousedown": (e) => e.preventDefault()
                }), {
                  actions: !props.hideActions ? () => {
                    var _a2;
                    return ((_a2 = slots.actions) == null ? void 0 : _a2.call(slots, {
                      save,
                      cancel,
                      isPristine
                    })) ?? actions();
                  } : void 0
                });
              }
            })]
          }), (_a = slots.default) == null ? void 0 : _a.call(slots)]);
        }
      });
    });
    return forwardRefs({}, vTextFieldRef);
  }
});
export {
  VDateInput
};
//# sourceMappingURL=vuetify_labs_VDateInput.js.map
